# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/jwt/all/jwt.rbi
#
# jwt-2.8.1

module JWT
  def decode(jwt, key = nil, verify = nil, options = nil, &keyfinder); end
  def encode(payload, key, algorithm = nil, header_fields = nil); end
  def self.decode(jwt, key = nil, verify = nil, options = nil, &keyfinder); end
  def self.encode(payload, key, algorithm = nil, header_fields = nil); end
  def self.gem_version; end
  def self.openssl_3?; end
  def self.openssl_3_hmac_empty_key_regression?; end
  def self.openssl_version; end
  def self.rbnacl?; end
  def self.rbnacl_6_or_greater?; end
  extend JWT::Configuration
end
module JWT::VERSION
end
class JWT::Base64
  def self.loose_urlsafe_decode64(str); end
  def self.url_decode(str); end
  def self.url_encode(str); end
end
class JWT::JSON
  def self.generate(data); end
  def self.parse(data); end
end
class JWT::EncodeError < StandardError
end
class JWT::DecodeError < StandardError
end
class JWT::RequiredDependencyError < StandardError
end
class JWT::VerificationError < JWT::DecodeError
end
class JWT::ExpiredSignature < JWT::DecodeError
end
class JWT::IncorrectAlgorithm < JWT::DecodeError
end
class JWT::ImmatureSignature < JWT::DecodeError
end
class JWT::InvalidIssuerError < JWT::DecodeError
end
class JWT::UnsupportedEcdsaCurve < JWT::IncorrectAlgorithm
end
class JWT::InvalidIatError < JWT::DecodeError
end
class JWT::InvalidAudError < JWT::DecodeError
end
class JWT::InvalidSubError < JWT::DecodeError
end
class JWT::InvalidJtiError < JWT::DecodeError
end
class JWT::InvalidPayload < JWT::DecodeError
end
class JWT::MissingRequiredClaim < JWT::DecodeError
end
class JWT::Base64DecodeError < JWT::DecodeError
end
class JWT::JWKError < JWT::DecodeError
end
class JWT::Verify
  def contains_key?(payload, key); end
  def exp_leeway; end
  def global_leeway; end
  def initialize(payload, options); end
  def nbf_leeway; end
  def self.verify_aud(payload, options); end
  def self.verify_claims(payload, options); end
  def self.verify_expiration(payload, options); end
  def self.verify_iat(payload, options); end
  def self.verify_iss(payload, options); end
  def self.verify_jti(payload, options); end
  def self.verify_not_before(payload, options); end
  def self.verify_required_claims(payload, options); end
  def self.verify_sub(payload, options); end
  def verify_aud; end
  def verify_expiration; end
  def verify_iat; end
  def verify_iss; end
  def verify_jti; end
  def verify_not_before; end
  def verify_required_claims; end
  def verify_sub; end
end
class JWT::X5cKeyFinder
  def build_store(root_certificates, crls); end
  def from(x5c_header_or_certificates); end
  def initialize(root_certificates, crls = nil); end
  def parse_certificates(x5c_header_or_certificates); end
end
class JWT::Decode
  def alg_in_header; end
  def allowed_algorithms; end
  def allowed_and_valid_algorithms; end
  def decode_segments; end
  def decode_signature; end
  def find_key(&keyfinder); end
  def given_algorithms; end
  def header; end
  def initialize(jwt, key, verify, options, &keyfinder); end
  def none_algorithm?; end
  def parse_and_decode(segment); end
  def payload; end
  def resolve_allowed_algorithms; end
  def segment_length; end
  def set_key; end
  def signing_input; end
  def sort_by_alg_header(algs); end
  def validate_segment_count!; end
  def verify_algo; end
  def verify_claims; end
  def verify_signature; end
  def verify_signature_for?(key); end
end
module JWT::Configuration
  def configuration; end
  def configure; end
end
class JWT::Configuration::DecodeConfiguration
  def algorithms; end
  def algorithms=(arg0); end
  def initialize; end
  def leeway; end
  def leeway=(arg0); end
  def required_claims; end
  def required_claims=(arg0); end
  def to_h; end
  def verify_aud; end
  def verify_aud=(arg0); end
  def verify_expiration; end
  def verify_expiration=(arg0); end
  def verify_iat; end
  def verify_iat=(arg0); end
  def verify_iss; end
  def verify_iss=(arg0); end
  def verify_jti; end
  def verify_jti=(arg0); end
  def verify_not_before; end
  def verify_not_before=(arg0); end
  def verify_sub; end
  def verify_sub=(arg0); end
end
module JWT::JWK
  def self.classes; end
  def self.create_from(key, params = nil, options = nil); end
  def self.generate_mappings; end
  def self.import(key, params = nil, options = nil); end
  def self.mappings; end
  def self.new(key, params = nil, options = nil); end
end
class JWT::JWK::KidAsKeyDigest
  def generate; end
  def initialize(jwk); end
end
class JWT::JWK::Thumbprint
  def generate; end
  def initialize(jwk); end
  def jwk; end
  def to_s; end
end
class JWT::Configuration::JwkConfiguration
  def initialize; end
  def kid_generator; end
  def kid_generator=(arg0); end
  def kid_generator_type=(value); end
end
class JWT::Configuration::Container
  def decode; end
  def decode=(arg0); end
  def deprecation_warnings; end
  def deprecation_warnings=(value); end
  def initialize; end
  def jwk; end
  def jwk=(arg0); end
  def reset!; end
  def strict_base64_decoding; end
  def strict_base64_decoding=(arg0); end
end
module JWT::Deprecations
  def self.record_warned(message); end
  def self.warning(message); end
end
module JWT::JWA
  def self.create(algorithm); end
  def self.find(algorithm); end
  def self.implementation?(algorithm); end
  def self.indexed; end
end
module JWT::JWA::Hmac
  def self.sign(algorithm, msg, key); end
  def self.verify(algorithm, key, signing_input, signature); end
  def sign(algorithm, msg, key); end
  def verify(algorithm, key, signing_input, signature); end
end
module JWT::JWA::Hmac::SecurityUtils
  def fixed_length_secure_compare(a, b); end
  def secure_compare(a, b); end
  def self.fixed_length_secure_compare(a, b); end
  def self.secure_compare(a, b); end
end
module JWT::JWA::Eddsa
  def self.sign(algorithm, msg, key); end
  def self.validate_algorithm!(algorithm); end
  def self.verify(algorithm, public_key, signing_input, signature); end
end
module JWT::JWA::Ecdsa
  def asn1_to_raw(signature, public_key); end
  def curve_by_name(name); end
  def raw_to_asn1(signature, private_key); end
  def self.asn1_to_raw(signature, public_key); end
  def self.curve_by_name(name); end
  def self.raw_to_asn1(signature, private_key); end
  def self.sign(algorithm, msg, key); end
  def self.verify(algorithm, public_key, signing_input, signature); end
  def sign(algorithm, msg, key); end
  def verify(algorithm, public_key, signing_input, signature); end
end
module JWT::JWA::Rsa
  def self.sign(algorithm, msg, key); end
  def self.verify(algorithm, public_key, signing_input, signature); end
  def sign(algorithm, msg, key); end
  def verify(algorithm, public_key, signing_input, signature); end
end
module JWT::JWA::Ps
  def self.sign(algorithm, msg, key); end
  def self.verify(algorithm, public_key, signing_input, signature); end
  def sign(algorithm, msg, key); end
  def verify(algorithm, public_key, signing_input, signature); end
end
module JWT::JWA::None
  def self.sign(*); end
  def self.verify(*); end
  def sign(*); end
  def verify(*); end
end
module JWT::JWA::Unsupported
  def self.sign(*); end
  def self.verify(*); end
  def sign(*); end
  def verify(*); end
end
class JWT::JWA::Wrapper
  def alg; end
  def cls; end
  def initialize(alg, cls); end
  def sign(data:, signing_key:); end
  def valid_alg?(alg_to_check); end
  def verify(data:, signature:, verification_key:); end
end
class JWT::ClaimsValidator
  def initialize(payload); end
  def validate!; end
  def validate_is_numeric(claim); end
  def validate_numeric_claims; end
end
class JWT::Encode
  def combine(*parts); end
  def encode_data(data); end
  def encode_header; end
  def encode_payload; end
  def encode_signature; end
  def encoded_header; end
  def encoded_header_and_payload; end
  def encoded_payload; end
  def encoded_signature; end
  def initialize(options); end
  def segments; end
  def signature; end
  def validate_claims!; end
end
class JWT::JWK::KeyFinder
  def initialize(options); end
  def key_for(kid); end
  def resolve_key(kid); end
end
class JWT::JWK::Set
  def +(enum); end
  def <<(key); end
  def ==(other); end
  def add(key); end
  def delete(*args, **, &block); end
  def dig(*args, **, &block); end
  def each(*args, **, &block); end
  def eql?(other); end
  def export(options = nil); end
  def filter!(&block); end
  def initialize(jwks = nil, options = nil); end
  def keys; end
  def length(*args, **, &block); end
  def merge(enum); end
  def reject!(&block); end
  def select!(&block); end
  def size(*args, **, &block); end
  def union(enum); end
  def uniq!(&block); end
  def |(enum); end
  extend Forwardable
  include Enumerable
end
class JWT::JWK::KeyBase
  def <=>(other); end
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def eql?(other); end
  def hash; end
  def initialize(options, params = nil); end
  def kid; end
  def parameters; end
  def self.inherited(klass); end
end
class JWT::JWK::EC < JWT::JWK::KeyBase
  def []=(key, value); end
  def check_jwk_params!(key_params, params); end
  def create_ec_key(jwk_crv, jwk_x, jwk_y, jwk_d); end
  def decode_octets(base64_encoded_coordinate); end
  def ec_key; end
  def encode_octets(octets); end
  def encode_open_ssl_bn(key_part); end
  def export(options = nil); end
  def extract_key_params(key); end
  def initialize(key, params = nil, options = nil); end
  def key_digest; end
  def keypair; end
  def keypair_components(ec_keypair); end
  def members; end
  def parse_ec_key(key); end
  def private?; end
  def public_key; end
  def self.import(jwk_data); end
  def self.to_openssl_curve(crv); end
  def signing_key; end
  def verify_key; end
end
class JWT::JWK::RSA < JWT::JWK::KeyBase
  def []=(key, value); end
  def check_jwk_params!(key_params, params); end
  def decode_open_ssl_bn(jwk_data); end
  def encode_open_ssl_bn(key_part); end
  def export(options = nil); end
  def extract_key_params(key); end
  def initialize(key, params = nil, options = nil); end
  def jwk_attributes(*attributes); end
  def key_digest; end
  def keypair; end
  def members; end
  def parse_rsa_key(key); end
  def private?; end
  def public_key; end
  def rsa_key; end
  def self.create_rsa_key(rsa_parameters); end
  def self.create_rsa_key_using_accessors(rsa_parameters); end
  def self.create_rsa_key_using_der(rsa_parameters); end
  def self.create_rsa_key_using_sets(rsa_parameters); end
  def self.decode_open_ssl_bn(jwk_data); end
  def self.import(jwk_data); end
  def self.validate_rsa_parameters!(rsa_parameters); end
  def signing_key; end
  def verify_key; end
end
class JWT::JWK::HMAC < JWT::JWK::KeyBase
  def []=(key, value); end
  def check_jwk(keypair, params); end
  def export(options = nil); end
  def extract_key_params(key); end
  def initialize(key, params = nil, options = nil); end
  def key_digest; end
  def keypair; end
  def members; end
  def private?; end
  def public_key; end
  def secret; end
  def self.import(jwk_data); end
  def signing_key; end
  def verify_key; end
end
